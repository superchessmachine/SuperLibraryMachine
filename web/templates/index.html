<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>SuperLibraryMachine RAG</title>
  <style>
    :root {
      --bg-color: #121212;
      --text-color: #e0e0e0;
      --accent-color: #4dabf7;
      --card-bg: #1e1e1e;
      --border-color: #2c2c2c;
      --input-bg: #2a2a2a;
    }

    body.light {
      --bg-color: #f5f5f5;
      --text-color: #222;
      --accent-color: #005f99;
      --card-bg: #fff;
      --border-color: #ccc;
      --input-bg: #fff;
    }

    body {
      margin: 0;
      font-family: 'Segoe UI', sans-serif;
      background-color: var(--bg-color);
      color: var(--text-color);
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 1rem;
      background: var(--card-bg);
      border-bottom: 1px solid var(--border-color);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
    }

    header h1 {
      flex: 1;
      margin: 0;
      font-size: 1.8rem;
      color: var(--accent-color);
      text-align: center;
    }

    .header-group {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    header button {
      padding: 0.35rem 0.85rem;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.95rem;
      transition: background 0.2s ease, color 0.2s ease;
    }

    .header-secondary {
      border: 1px solid var(--accent-color);
      background: none;
      color: var(--accent-color);
    }

    .header-primary {
      border: none;
      background: var(--accent-color);
      color: #000;
    }

    #chat-log {
      flex: 1;
      overflow-y: auto;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .chat-box {
      max-width: 900px;
      width: 100%;
      margin: 0 auto;
      background: var(--card-bg);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 1rem;
      white-space: pre-wrap;
    }

    .chat-box.user { border-left: 5px solid var(--accent-color); }
    .chat-box.assistant { border-left: 5px solid #8bc34a; }

    .chat-box.citations {
      font-size: 0.9rem;
      color: var(--accent-color);
    }

    .chat-box.citations a {
      color: var(--accent-color);
      text-decoration: none;
    }

    .chat-box.citations a:hover {
      text-decoration: underline;
    }

    .chat-box ul,
    .chat-box ol {
      margin: 0.5rem 0;
      padding-left: 1.5rem;
    }

    .chat-box li + li {
      margin-top: 0.25rem;
    }

    footer {
      border-top: 1px solid var(--border-color);
      padding: 1rem;
      background-color: var(--card-bg);
    }

    footer form {
      max-width: 900px;
      margin: 0 auto;
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
    }

    select, input[type="text"], input[type="number"] {
      padding: 0.5rem;
      background-color: var(--input-bg);
      border: 1px solid var(--border-color);
      color: var(--text-color);
      border-radius: 6px;
      font-size: 1rem;
    }

    select {
      width: 200px;
    }

    input[type="text"], input[type="number"] {
      flex: 1;
    }

    footer button[type="submit"] {
      padding: 0.6rem 1.2rem;
      font-size: 1rem;
      border: none;
      border-radius: 6px;
      background-color: var(--accent-color);
      color: #000;
      cursor: pointer;
    }

    .modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.6);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1rem;
      z-index: 1000;
    }

    .modal.hidden {
      display: none;
    }

    .modal-content {
      position: relative;
      width: min(980px, 95vw);
      max-height: 90vh;
      overflow-y: auto;
      background: var(--card-bg);
      border: 1px solid var(--border-color);
      border-radius: 10px;
      padding: 1.5rem;
      box-shadow: 0 16px 40px rgba(0, 0, 0, 0.4);
    }

    .modal-close {
      position: absolute;
      top: 0.75rem;
      right: 0.75rem;
      border: none;
      background: none;
      color: var(--text-color);
      font-size: 1.5rem;
      cursor: pointer;
    }

    body.modal-open {
      overflow: hidden;
    }

    #builder-section {
      padding: 0.5rem 0 0;
    }

    #builder-section h2 {
      margin: 0 0 0.75rem;
      font-size: 1.4rem;
      color: var(--accent-color);
    }

    #builder-section p {
      margin: 0 0 1rem;
      font-size: 0.95rem;
      color: var(--text-color);
    }

    #builder-form {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .builder-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
    }

    .builder-row label {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      font-size: 0.95rem;
    }

    .builder-checkboxes {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      font-size: 0.95rem;
    }

    .builder-checkboxes label {
      display: flex;
      align-items: center;
      gap: 0.35rem;
    }

    details.builder-advanced {
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 0.25rem 0.75rem 0.75rem;
      background: var(--bg-color);
    }

    details.builder-advanced summary {
      cursor: pointer;
      font-weight: 600;
      color: var(--accent-color);
      margin: 0.5rem 0;
      outline: none;
    }

    .builder-advanced-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 1rem;
    }

    .builder-advanced-grid fieldset {
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 0.75rem;
    }

    .builder-advanced-grid legend {
      padding: 0 0.5rem;
      font-size: 0.9rem;
      color: var(--accent-color);
    }

    .builder-advanced-grid label {
      font-size: 0.9rem;
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      margin-bottom: 0.65rem;
    }

    #build-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: center;
    }

    #build-submit {
      padding: 0.6rem 1.2rem;
      font-size: 1rem;
      border: none;
      border-radius: 6px;
      background-color: var(--accent-color);
      color: #000;
      cursor: pointer;
    }

    #build-submit[disabled] {
      opacity: 0.5;
      cursor: not-allowed;
    }

    #build-status {
      font-size: 0.95rem;
    }

    #build-log {
      max-width: 100%;
      margin: 0.5rem 0 0;
      background: var(--input-bg);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      padding: 0.75rem;
      font-family: 'Fira Code', 'Courier New', monospace;
      font-size: 0.85rem;
      white-space: pre-wrap;
      max-height: 260px;
      overflow-y: auto;
    }

    #build-log.hidden {
      display: none;
    }

    #settings-form {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      margin-top: 1rem;
    }

    #settings-form label {
      font-size: 0.95rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    #settings-form input[type="password"],
    #settings-form input[type="text"] {
      padding: 0.6rem;
      background-color: var(--input-bg);
      border: 1px solid var(--border-color);
      color: var(--text-color);
      border-radius: 6px;
      font-size: 1rem;
    }

    #settings-actions {
      display: flex;
      gap: 0.75rem;
      flex-wrap: wrap;
    }

    #settings-actions button {
      padding: 0.55rem 1.1rem;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      font-size: 0.95rem;
    }

    #save-api-key {
      background: var(--accent-color);
      color: #000;
    }

    #clear-api-key {
      background: none;
      border: 1px solid var(--accent-color);
      color: var(--accent-color);
    }

    #settings-status {
      font-size: 0.95rem;
    }

    #spinner {
      display: none;
      font-weight: bold;
      align-items: center;
      gap: 0.5rem;
    }

    .spinner-icon {
      border: 4px solid #444;
      border-top: 4px solid var(--accent-color);
      border-radius: 50%;
      width: 20px;
      height: 20px;
      animation: spin 1s linear infinite;
      display: inline-block;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <header>
    <div class="header-group">
      <button id="clear-history" class="header-secondary">Clear History</button>
      <button id="open-builder" class="header-primary">Build Database</button>
    </div>
    <h1>SuperLibraryMachine RAG</h1>
    <div class="header-group">
      <button id="toggle-theme" class="header-secondary">Toggle Theme</button>
      <button id="open-settings" class="header-secondary">Settings</button>
    </div>
  </header>

  <div id="builder-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="builder-title">
    <div class="modal-content">
      <button type="button" class="modal-close" id="close-builder" aria-label="Close builder dialog">&times;</button>
      <section id="builder-section">
        <h2 id="builder-title">Build a New Database</h2>
        <p>Databases are stored under <code>{{ db_root }}</code>. Provide the folder containing your PDF papers and adjust any options below.</p>
        <form id="builder-form">
      <div class="builder-row">
        <label for="db-name">
          Database name
          <input id="db-name" name="dbName" type="text" pattern="[A-Za-z0-9._-]+" placeholder="my_database" required>
        </label>
        <label for="papers-dir">
          Folder with PDFs
          <input id="papers-dir" name="papersDir" type="text" placeholder="/path/to/papers" required>
        </label>
      </div>

      <div class="builder-checkboxes">
        <label><input type="checkbox" name="recursive"> Search recursively</label>
        <label><input type="checkbox" name="skipOrganize" checked> Skip organizing PDFs (keep originals in place)</label>
      </div>

      <details class="builder-advanced">
        <summary>Advanced options</summary>
        <div class="builder-advanced-grid">
          <fieldset>
            <legend>File &amp; path outputs</legend>
            <label>
              PDF output directory
              <input type="text" name="pdfDir" data-default-suffix="pdf">
            </label>
            <label>
              TXT output directory
              <input type="text" name="txtDir" data-default-suffix="txt">
            </label>
            <label>
              Metadata CSV file
              <input type="text" name="metadataFile" data-default-suffix="metadata.csv">
            </label>
            <label>
              Chunk JSONL output
              <input type="text" name="chunkOutput" data-default-suffix="chunksatleast500.jsonl">
            </label>
            <label>
              Embedding JSONL output
              <input type="text" name="embeddingOutput" data-default-suffix="embedded_chunks_atleast500.jsonl">
            </label>
            <label>
              Embedding shard directory
              <input type="text" name="embeddingShardDir" data-default-suffix="output_shards">
            </label>
            <label>
              FAISS index file
              <input type="text" name="faissIndex" data-default-suffix="faiss_index.idx">
            </label>
            <label>
              FAISS metadata file
              <input type="text" name="faissMetadata" data-default-suffix="faiss_metadata.pkl">
            </label>
          </fieldset>

          <fieldset>
            <legend>Conversion &amp; metadata</legend>
            <label>
              Conversion workers (number or "auto")
              <input type="text" name="conversionWorkers" placeholder="auto">
            </label>
            <label><input type="checkbox" name="conversionNoOverwrite"> Do not overwrite existing TXT files</label>
            <label><input type="checkbox" name="skipCleanup"> Skip macOS metadata cleanup</label>
            <label><input type="checkbox" name="cleanupShallow"> Cleanup only top-level metadata files</label>
            <label>
              Metadata encoding
              <input type="text" name="metadataEncoding" placeholder="utf-8">
            </label>
            <label><input type="checkbox" name="metadataIncludeRelPath"> Include relative TXT paths in metadata</label>
          </fieldset>

          <fieldset>
            <legend>Chunking</legend>
            <label>
              Minimum tokens per chunk
              <input type="number" name="minTokens" min="1" step="1" placeholder="500">
            </label>
            <label>
              Chunk overlap
              <input type="number" name="chunkOverlap" min="0" step="1" placeholder="1">
            </label>
            <label>
              Tokenizer name
              <input type="text" name="tokenizer" placeholder="cl100k_base">
            </label>
            <label>
              Chunk workers (number or "auto")
              <input type="text" name="chunkWorkers" placeholder="auto">
            </label>
          </fieldset>

          <fieldset>
            <legend>Embedding</legend>
            <label>
              SentenceTransformer model
              <input type="text" name="embeddingModel" placeholder="all-MiniLM-L6-v2">
            </label>
            <label>
              Embedding batch size
              <input type="number" name="embeddingBatchSize" min="1" step="1" placeholder="2048">
            </label>
            <label>
              Embedding workers
              <input type="number" name="embeddingWorkers" min="1" step="1" placeholder="4">
            </label>
            <label>
              Embedding device
              <select name="embeddingDevice">
                <option value="">default (gpu)</option>
                <option value="gpu">gpu</option>
                <option value="cpu">cpu</option>
              </select>
            </label>
            <label><input type="checkbox" name="normalizeEmbeddings"> Normalize embeddings</label>
          </fieldset>

          <fieldset>
            <legend>FAISS index</legend>
            <label>
              Similarity metric
              <select name="faissMetric">
                <option value="">l2 (default)</option>
                <option value="l2">l2</option>
                <option value="cosine">cosine</option>
              </select>
            </label>
          </fieldset>
        </div>
      </details>

      <div id="build-actions">
        <button type="submit" id="build-submit">Build database</button>
        <span id="build-status"></span>
      </div>
    </form>
    <pre id="build-log" class="hidden"></pre>
  </section>
    </div>
  </div>

  <div id="settings-modal" class="modal hidden" role="dialog" aria-modal="true" aria-labelledby="settings-title">
    <div class="modal-content">
      <button type="button" class="modal-close" id="close-settings" aria-label="Close settings dialog">&times;</button>
      <h2 id="settings-title">Settings</h2>
      <p>Provide your API key so the server can call OpenAI models. The key is stored only for the current server process.</p>
      <form id="settings-form">
        <label for="api-key-input">
          OpenAI API key
          <input id="api-key-input" name="apiKey" type="password" placeholder="sk-..." autocomplete="off">
        </label>
        <div id="settings-actions">
          <button type="submit" id="save-api-key">Save key</button>
          <button type="button" id="clear-api-key">Clear key</button>
        </div>
        <span id="settings-status"></span>
      </form>
    </div>
  </div>

  <div id="chat-log"></div>

  <footer>
    <form id="query-form" method="POST" onsubmit="handleSubmit(event)">
      <select name="db" required {% if not databases %}disabled{% endif %}>
        {% if databases %}
          {% for db in databases %}
            <option value="{{ db }}" {% if db == selected_db %}selected{% endif %}>{{ db }}</option>
          {% endfor %}
        {% else %}
          <option value="">No databases available</option>
        {% endif %}
      </select>

      <input type="text" name="query" placeholder="Your question..." required {% if not databases %}disabled{% endif %}>
      <button type="submit" id="submit-button" {% if not databases %}disabled{% endif %}>Ask</button>
      <div id="spinner"><span class="spinner-icon"></span> Processing…</div>
    </form>
  </footer>

  <script>
    const dbRoot = {{ db_root|tojson }};
    let hasDatabases = {{ (databases|length > 0)|lower }};

    const queryForm = document.getElementById("query-form");
    const queryInput = queryForm ? queryForm.querySelector('input[name="query"]') : null;
    const spinner = document.getElementById("spinner");
    const submitBtn = document.getElementById("submit-button");
    const dbSelect = document.querySelector('select[name="db"]');

    const builderModal = document.getElementById("builder-modal");
    const openBuilderBtn = document.getElementById("open-builder");
    const closeBuilderBtn = document.getElementById("close-builder");
    const settingsModal = document.getElementById("settings-modal");
    const openSettingsBtn = document.getElementById("open-settings");
    const closeSettingsBtn = document.getElementById("close-settings");

    const builderForm = document.getElementById("builder-form");
    const buildSubmit = document.getElementById("build-submit");
    const buildStatus = document.getElementById("build-status");
    const buildLog = document.getElementById("build-log");
    const dbNameInput = document.getElementById("db-name");

    const clearHistoryBtn = document.getElementById("clear-history");
    const toggleThemeBtn = document.getElementById("toggle-theme");
    const settingsForm = document.getElementById("settings-form");
    const apiKeyInput = document.getElementById("api-key-input");
    const settingsStatus = document.getElementById("settings-status");
    const clearApiKeyBtn = document.getElementById("clear-api-key");

    function applyInlineFormatting(text) {
      if (!text) return "";
      return text
        .replace(/\*\*(.*?)\*\*/g, "<strong>$1</strong>")
        .replace(/__(.*?)__/g, "<strong>$1</strong>");
    }

    function formatAssistantText(raw) {
      if (!raw) return "";
      const normalized = raw
        .replace(/\r\n/g, "\n")
        .replace(/\t+/g, "    ")
        .replace(/\s{2,}•/g, "\n•")
        .replace(/\s{2,}(\d+\.)/g, "\n$1");
      const lines = normalized.split("\n");
      const parts = [];

      let listType = null;
      let paragraphBuffer = [];

      const closeParagraph = () => {
        if (!paragraphBuffer.length) return;
        const paragraphText = paragraphBuffer.join(" ").trim();
        if (paragraphText) {
          parts.push(`<p>${applyInlineFormatting(paragraphText)}</p>`);
        }
        paragraphBuffer = [];
      };

      const closeList = () => {
        if (!listType) return;
        parts.push(`</${listType}>`);
        listType = null;
      };

      const openList = (type, start = 1) => {
        if (listType === type) return;
        closeList();
        if (type === "ol") {
          parts.push(start !== 1 ? `<ol start="${start}">` : "<ol>");
        } else {
          parts.push("<ul>");
        }
        listType = type;
      };

      lines.forEach(line => {
        const trimmed = line.trim();

        if (!trimmed) {
          closeParagraph();
          closeList();
          return;
        }

        const orderedMatch = trimmed.match(/^(\d+)\.\s+(.*)$/);
        if (orderedMatch) {
          closeParagraph();
          const start = parseInt(orderedMatch[1], 10) || 1;
          if (listType !== "ol") {
            openList("ol", start);
          }
          parts.push(`<li>${applyInlineFormatting(orderedMatch[2])}</li>`);
          return;
        }

        const bulletMatch = trimmed.match(/^[\u2022\*\-]\s+(.*)$/);
        if (bulletMatch) {
          closeParagraph();
          if (listType !== "ul") {
            openList("ul");
          }
          parts.push(`<li>${applyInlineFormatting(bulletMatch[1])}</li>`);
          return;
        }

        closeList();
        paragraphBuffer.push(trimmed);
      });

      closeParagraph();
      closeList();

      return parts.join("").replace(/(<br>){3,}/g, "<br><br>");
    }

    function handleSubmit(event) {
      if (spinner) spinner.style.display = "flex";
      if (submitBtn) submitBtn.style.display = "none";
      if (queryInput) {
        localStorage.setItem("lastQuery", queryInput.value);
      }
    }

    if (clearHistoryBtn) {
      clearHistoryBtn.onclick = () => {
        localStorage.removeItem("chatHistory");
        location.reload();
      };
    }

    if (toggleThemeBtn) {
      toggleThemeBtn.onclick = () => {
        document.body.classList.toggle("light");
      };
    }

    function updateBodyModalState() {
      const anyOpen = document.querySelector(".modal:not(.hidden)") !== null;
      document.body.classList.toggle("modal-open", anyOpen);
    }

    function openModal(modal) {
      if (!modal) return;
      modal.classList.remove("hidden");
      updateBodyModalState();
      const focusTarget =
        modal.querySelector("form input, form select, form textarea") ||
        modal.querySelector("button, [href], input, select, textarea");
      if (focusTarget) {
        setTimeout(() => focusTarget.focus(), 0);
      }
    }

    function closeModal(modal) {
      if (!modal) return;
      modal.classList.add("hidden");
      updateBodyModalState();
    }

    if (openBuilderBtn && builderModal) {
      openBuilderBtn.onclick = () => {
        updatePathDefaults(false);
        if (buildStatus) buildStatus.textContent = "";
        if (buildLog) {
          buildLog.textContent = "";
          buildLog.classList.add("hidden");
        }
        openModal(builderModal);
      };
    }

    if (closeBuilderBtn && builderModal) {
      closeBuilderBtn.onclick = () => closeModal(builderModal);
    }

    if (openSettingsBtn && settingsModal) {
      openSettingsBtn.onclick = () => {
        if (settingsStatus) settingsStatus.textContent = "";
        openModal(settingsModal);
      };
    }

    if (closeSettingsBtn && settingsModal) {
      closeSettingsBtn.onclick = () => {
        closeModal(settingsModal);
        if (settingsStatus) settingsStatus.textContent = "";
      };
    }

    [builderModal, settingsModal].forEach(modal => {
      if (!modal) return;
      modal.addEventListener("click", event => {
        if (event.target === modal) {
          if (modal === settingsModal && settingsStatus) {
            settingsStatus.textContent = "";
          }
          closeModal(modal);
        }
      });
    });

    document.addEventListener("keydown", event => {
      if (event.key === "Escape") {
        if (builderModal && !builderModal.classList.contains("hidden")) {
          closeModal(builderModal);
          event.preventDefault();
          return;
        }
        if (settingsModal && !settingsModal.classList.contains("hidden")) {
          closeModal(settingsModal);
          event.preventDefault();
        }
      }
    });

    document.addEventListener("DOMContentLoaded", () => {
      const log = document.getElementById("chat-log");
      if (!log) return;

      const raw = `{{ answer | e }}`;
      const query = localStorage.getItem("lastQuery") || "";
      const citeBox = `{% if citations %}<div class='chat-box citations'><strong>Citations:</strong><ul>{% for num, doi in citations|dictsort(true) %}<li>[{{ num }}]: {% if doi != "N/A" %}<a href="https://pubmed.ncbi.nlm.nih.gov/?term={{ doi | urlencode }}&sort=pubdate&size=200" target="_blank">{{ doi }}</a>{% else %}DOI not available{% endif %}</li>{% endfor %}</ul></div>{% endif %}`;
      const history = JSON.parse(localStorage.getItem("chatHistory") || "[]");

      if (raw.trim()) {
        const cleaned = formatAssistantText(raw);

        history.push({ q: query, a: cleaned, c: citeBox });
        localStorage.setItem("chatHistory", JSON.stringify(history));
        localStorage.removeItem("lastQuery");
      }

      log.innerHTML = "";

      if (!hasDatabases && history.length === 0) {
        const notice = document.createElement("div");
        notice.id = "db-notice";
        notice.className = "chat-box assistant";
        notice.style.borderLeftColor = "#f39c12";
        notice.innerHTML = `<strong>No databases detected.</strong><br>Place a processed RAG database inside <code>${dbRoot}</code> so the assistant can answer questions.`;
        log.appendChild(notice);
      }

      history.forEach(entry => {
        const uq = document.createElement("div");
        uq.className = "chat-box user";
        uq.innerHTML = "<strong>You asked:</strong><br>" + entry.q;

        const ua = document.createElement("div");
        ua.className = "chat-box assistant";
        ua.innerHTML = "<strong>Assistant:</strong><br>" + entry.a;

        const uc = document.createElement("div");
        uc.className = "chat-box citations";
        uc.innerHTML = entry.c;

        log.appendChild(uq);
        log.appendChild(ua);
        log.appendChild(uc);
      });

      log.scrollTop = log.scrollHeight;
    });

    if (queryInput && queryForm) {
      queryInput.addEventListener("keypress", e => {
        if (e.key === "Enter") {
          e.preventDefault();
          queryForm.requestSubmit();
        }
      });
    }

    let pathInputs = [];

    function sanitizeDbNameForPath(name) {
      return name.replace(/[^\w.\-]/g, "_");
    }

    function updatePathDefaults(force = false) {
      if (!builderForm || !dbNameInput || !pathInputs.length) return;

      const rawName = dbNameInput.value.trim();
      if (!rawName) {
        pathInputs.forEach(input => {
          if (force || input.dataset.dirty !== "true") {
            input.value = "";
          }
        });
        return;
      }

      const safeName = sanitizeDbNameForPath(rawName);
      const base = dbRoot.replace(/[\\/]+$/, "");

      pathInputs.forEach(input => {
        if (!force && input.dataset.dirty === "true") return;
        const suffix = input.dataset.defaultSuffix || "";
        input.value = `${base}/${safeName}${suffix ? `/${suffix}` : ""}`;
      });
    }

    function refreshDatabaseOptions(databases, selectedDb) {
      if (!dbSelect) return;

      dbSelect.innerHTML = "";

      if (!Array.isArray(databases) || databases.length === 0) {
        const option = document.createElement("option");
        option.value = "";
        option.textContent = "No databases available";
        option.disabled = true;
        option.selected = true;
        dbSelect.appendChild(option);
        dbSelect.disabled = true;
        if (queryInput) queryInput.disabled = true;
        if (submitBtn) submitBtn.disabled = true;
        return;
      }

      databases.forEach(name => {
        const option = document.createElement("option");
        option.value = name;
        option.textContent = name;
        if (name === selectedDb) option.selected = true;
        dbSelect.appendChild(option);
      });

      dbSelect.disabled = false;
      if (queryInput) queryInput.disabled = false;
      if (submitBtn) {
        submitBtn.disabled = false;
        submitBtn.style.display = "";
      }
    }

    function toggleBuilderControls(disabled) {
      if (!builderForm) return;
      const controls = builderForm.querySelectorAll("input, select, button");
      controls.forEach(control => {
        control.disabled = disabled;
      });
      if (buildSubmit) buildSubmit.disabled = disabled;
    }

    async function submitApiKey(apiKeyValue) {
      const response = await fetch("/settings/api-key", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ apiKey: apiKeyValue }),
      });
      const data = await response.json().catch(() => ({}));
      if (!response.ok || data.ok !== true) {
        const errorMessage = data.error || `Request failed${response.status ? ` (${response.status})` : ""}.`;
        throw new Error(errorMessage);
      }
      return data;
    }

    if (settingsForm) {
      settingsForm.addEventListener("submit", async event => {
        event.preventDefault();
        if (!settingsStatus) return;
        const value = apiKeyInput ? apiKeyInput.value.trim() : "";
        settingsStatus.textContent = "Saving key…";
        try {
          const result = await submitApiKey(value || null);
          const successMessage = result.message || "✅ API key saved for this session.";
          settingsStatus.textContent = successMessage;
          if (apiKeyInput) apiKeyInput.value = "";
        } catch (error) {
          const message = error instanceof Error ? error.message : "Failed to save API key.";
          settingsStatus.textContent = `❌ ${message}`;
        }
      });
    }

    if (clearApiKeyBtn) {
      clearApiKeyBtn.addEventListener("click", async () => {
        if (!settingsStatus) return;
        settingsStatus.textContent = "Clearing key…";
        try {
          const result = await submitApiKey(null);
          settingsStatus.textContent = result.message || "✅ API key cleared.";
          if (apiKeyInput) apiKeyInput.value = "";
        } catch (error) {
          const message = error instanceof Error ? error.message : "Failed to clear API key.";
          settingsStatus.textContent = `❌ ${message}`;
        }
      });
    }

    if (builderForm) {
      pathInputs = Array.from(builderForm.querySelectorAll("[data-default-suffix]"));
      pathInputs.forEach(input => {
        input.addEventListener("input", () => {
          input.dataset.dirty = "true";
        });
      });

      if (dbNameInput) {
        dbNameInput.addEventListener("input", () => updatePathDefaults(false));
      }

      updatePathDefaults(true);

      builderForm.addEventListener("submit", async event => {
        event.preventDefault();
        if (!buildSubmit || !buildStatus) return;

        if (!builderForm.reportValidity()) {
          return;
        }

        const formData = new FormData(builderForm);

        buildStatus.textContent = "Starting build…";
        buildLog.textContent = "";
        buildLog.classList.add("hidden");

        const payload = {
          dbName: (formData.get("dbName") || "").toString().trim(),
          papersDir: (formData.get("papersDir") || "").toString().trim(),
          options: {},
        };

        const boolFields = [
          "recursive",
          "skipCleanup",
          "cleanupShallow",
          "skipOrganize",
          "conversionNoOverwrite",
          "metadataIncludeRelPath",
          "normalizeEmbeddings",
        ];

        boolFields.forEach(key => {
          payload.options[key] = formData.get(key) === "on";
        });

        const valueFields = [
          "pdfDir",
          "txtDir",
          "metadataFile",
          "chunkOutput",
          "embeddingOutput",
          "embeddingShardDir",
          "faissIndex",
          "faissMetadata",
          "conversionWorkers",
          "metadataEncoding",
          "minTokens",
          "chunkOverlap",
          "tokenizer",
          "chunkWorkers",
          "embeddingModel",
          "embeddingBatchSize",
          "embeddingWorkers",
          "embeddingDevice",
          "faissMetric",
        ];

        valueFields.forEach(key => {
          const raw = formData.get(key);
          const cleaned = typeof raw === "string" ? raw.trim() : "";
          payload.options[key] = cleaned || null;
        });

        let result = null;

        toggleBuilderControls(true);

        try {
          const response = await fetch("/build", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });
          try {
            result = await response.json();
          } catch (jsonError) {
            result = null;
          }

          if (!response.ok || !result || result.ok !== true) {
            const message =
              (result && result.error) ||
              `Request failed${response.status ? ` (${response.status})` : ""}.`;
            throw new Error(message);
          }

          const trimmedLogs = (result.logs || "").trim();
          if (trimmedLogs) {
            buildLog.textContent = trimmedLogs;
            buildLog.classList.remove("hidden");
            buildLog.scrollTop = buildLog.scrollHeight;
          } else {
            buildLog.classList.add("hidden");
          }

          buildStatus.textContent = `✅ Database '${result.database}' built successfully.`;
          if (Array.isArray(result.databases)) {
            refreshDatabaseOptions(result.databases, result.database);
          }
          hasDatabases = true;
          const notice = document.getElementById("db-notice");
          if (notice) notice.remove();

          builderForm.reset();
          pathInputs.forEach(input => {
            delete input.dataset.dirty;
          });
          updatePathDefaults(true);
        } catch (error) {
          const message = error instanceof Error ? error.message : "Build failed.";
          buildStatus.textContent = `❌ ${message}`;
          const errorLogs = result && typeof result.logs === "string" ? result.logs.trim() : "";
          if (errorLogs) {
            buildLog.textContent = errorLogs;
            buildLog.classList.remove("hidden");
            buildLog.scrollTop = buildLog.scrollHeight;
          }
        } finally {
          toggleBuilderControls(false);
        }
      });
    }
  </script>
</body>
</html>
